[{"content":"Manacher算法是一个用于查找字符串中最长回文子串的算法，在经过O(n)时间复杂度的预处理后，可以在O(1)时间内判断某个子串是否为回文串。本文将从一道力扣出发，展开说说Manacher是啥，如何从零写出Manacher，怎么理解并记忆。\n力扣647. 回文子串 题目描述 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n示例 示例 1：\n输入：\u0026ldquo;abc\u0026rdquo; 输出：3 解释：三个回文子串: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;\n示例 2：\n输入：\u0026ldquo;aaa\u0026rdquo; 输出：6 解释：6个回文子串: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;a\u0026rdquo;, \u0026ldquo;a\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aaa\u0026rdquo;\n解题思路 从Bruteforce出发，我们可遍历每一个位置，从中心向两边展开来判断是否为回文串，但这样时间复杂度是O(n^2)。这里其实有优化的空间，比如这个串\u0026quot;xabacabay\u0026quot;，当我们判断出以c为中心的串\u0026quot;abacaba\u0026quot;是一个回文串时，我们可以知道以第二个b为中心的子串\u0026quot;aba\u0026quot;可以使用对称性通过前一个子串\u0026quot;aba\u0026quot;的判断结果得到，因为以c为中心的串覆盖了前后两个以b为中心的串，而前一个以b为中心的子串已经判断过了，我们不需要再判断。 上述优化的重点在于，我们需要知道当前要判断的子串是否被之前已经判断过的子串覆盖了，如果覆盖，那么可以O(1)时间通过查表得到结果。\n奇偶长度的问题 我们注意到，回文串的长度可能是奇数也可能是偶数，比如\u0026quot;aba\u0026quot;和\u0026quot;abba\u0026quot;。为了解决这个问题，我们可以在每个字符之间插入一个特殊字符，比如\u0026quot;#\u0026quot;,这样所有的回文串的长度都是奇数了。比如\u0026quot;aba\u0026quot;插入特殊字符后变成\u0026quot;a#b#a\u0026quot;，\u0026ldquo;abba\u0026quot;插入特殊字符后变成\u0026quot;a#b#b#a\u0026rdquo;。这样我们就可以统一处理奇偶长度的回文串了。\n具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 input -\u0026gt; s = ababd def manacher(s: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34; 1. 需要插入特殊字符进行来解决奇偶长度的问题, t = ^#a#b#a#b#d#$ idx 01234567890 0 1 2 3 4 为了在暴力搜索时防止溢出问题，我们可以在前后加上两个一定不会匹配到的字符 下标映射关系为 t_i = 2 * (s_i + 1), len_t = 2 * len_s + 3 \u0026#34;\u0026#34;\u0026#34; t = \u0026#39;#\u0026#39;.join(\u0026#39;^\u0026#39; + s + \u0026#39;$\u0026#39;) \u0026#34;\u0026#34;\u0026#34; 2. 我们需要一个O(n)的数组来记录以每个字符为中心的最长子串的长度，这里为了简化，使用半长度数组来表示，即halflen_t[i] = (len_t[i] + 1) // 2 halflen = [0] * len_t 我们还需要记录，当前最长子串的中心和半长度。（毕竟我们每次都希望当前最长子串覆盖尽可能多的子串） max_center = 0 max_halflen = 0 \u0026#34;\u0026#34;\u0026#34; max_center = 0 max_halflen = 0 max_i = 0 # 记录最长子串的中心 half_len = [0] * len(t) half_len[1] = 1 # ‘#’肯定能匹配到一个 for i in range(2, len(t) - 2): # 3. 遍历t，对于每个字符，我们首先判断它是否在最长子串的覆盖范围内，如果在，则可以通过对称性得到 hl = min(half_len[2 * max_center - i], max_center + max_halflen - hl) # 这里还需要判断max_halflen - hl的值，不然有可能溢出, 比如 abacab，第二个b和第一个b对称，但其实后面已经没有字符了 if i \u0026lt; max_center + max_halflen: hl = min(half_len[2 * max_center - i], max_center + max_halflen - hl) # 继续暴力搜索 while t[i - hl] == t[i + hl]: hl += 1 max_center, max_halflen = i, hl half_len[i] = hl if hl \u0026gt; halflen[max_i]: max_i = i hl = half_len[max_i] # 根据max_i和hl来提取出s即可, 因为最长子串最外圈一定包括#，注意左闭右开 t[max_i - hl + 2: max_i + hl - 2 + 1] # t_i = 2 * (s_i + 1) \u0026lt;==\u0026gt; s_i = t_i // 2 - 1 return s[(max_i - hl) // 2: (max_i + h_i) // 2 - 2 + 1] 总结 Manacher算法的核心思想是通过预处理来减少重复计算，通过记录最长子串的中心和半长度，可以在O(1)时间内判断某个子串是否为回文串。同时，通过在字符串中插入特殊字符，可以统一处理奇偶长度的回文串。\n","date":"2025-02-04T14:26:56+01:00","permalink":"https://example.com/p/manacher_algorithm/","title":"Manacher_algorithm"},{"content":"docker的三个基本概念 Image 分层存储 镜像并非是像一个ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。\n镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。因此，在构建镜像的时候，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\nContainer 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。\nRepository 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。 一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。\n通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 \u0026lt;仓库名\u0026gt;:\u0026lt;标签\u0026gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\n以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。\n使用镜像 获取镜像 $ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n1 2 3 4 5 6 7 8 $ docker pull ubuntu:18.04 18.04: Pulling from library/ubuntu 92dc2a97ff99: Pull complete be13a9d27eb8: Pull complete c8299583700a: Pull complete Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26 Status: Downloaded newer image for ubuntu:18.04 docker.io/library/ubuntu:18.04 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ docker run -it --rm ubuntu:18.04 bash root@e7009c6ce357:/# cat /etc/os-release NAME=\u0026#34;Ubuntu\u0026#34; VERSION=\u0026#34;18.04.1 LTS (Bionic Beaver)\u0026#34; ID=ubuntu ID_LIKE=debian PRETTY_NAME=\u0026#34;Ubuntu 18.04.1 LTS\u0026#34; VERSION_ID=\u0026#34;18.04\u0026#34; HOME_URL=\u0026#34;https://www.ubuntu.com/\u0026#34; SUPPORT_URL=\u0026#34;https://help.ubuntu.com/\u0026#34; BUG_REPORT_URL=\u0026#34;https://bugs.launchpad.net/ubuntu/\u0026#34; PRIVACY_POLICY_URL=\u0026#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\u0026#34; VERSION_CODENAME=bionic UBUNTU_CODENAME=bionic ","date":"2024-12-12T13:39:49+01:00","permalink":"https://example.com/p/docker-%E5%88%9D%E8%AF%86/","title":"Docker 初识"},{"content":" “剪发新模式，只要15元，60岁以上只要10元！”\n明天国庆节要出门玩，所以今天晚上去剪个头发。好久不在国内剪发了，去小区附近常去的那家店一看，普通价50，会员价35。我心里一嘀咕：又是骗老子开会员，这tm也太贵了。也就过去了一年多的时间吧，现在国内剪个头发价格如此夸张？！我突然想重拾我在苏黎世的时候自己学剪发的手艺了。我尝试过一次，一顿操作下，给自己的后脑剪了个参差不齐，虽然也向室友要到了夸夸。但我洗头时摸了摸后脑勺，顿时一惊，第二天又找了个理发店修了一下。（感谢我的室友鼓励而不是嘲笑我）\n言归正传，我当然不可能去剪50元的头，在我的印象中，剪头发这种事情，20最多了。碰巧最近在外面吃饭经过一家“快剪店”，门口的大喇叭让我想起了小时候最喜欢唱的《小薇》，一首街边揽客神曲。虽然我不太了解什么是“快剪”，而且我一向觉得便宜没好货，贵的东西价格只有贵，但不妨一试嘛。（其实是我不知道哪里还有理发店，死宅就是这样的啦）\n门口正摆着了一个扫码下单取号的机器，我选了个最便宜的，15元。好家伙，真的便宜，看着老板还挺潮的样子，我打算试试。\n到我了，我立马展现出一副社会二流子的模样，和老板攀谈起来，后来发现原来这人也是打工的。这是一家在（可能）江浙沪的剪发连锁店（居然还有这种东西？剪头发也可以搞这种薄利多销的模式，我还挺感兴趣的）。门面位置还不错，人流量挺大，店里每天大概有上百人来剪头发，平均客单价20左右，店里有两个人负责箭头，没有收银（门口的机器），月租多少没说（他说他也不知道，毕竟不是老板，只是个打工仔）。他说他是四川人，来这边打工。我阅历比较少，以为他老婆在这，否则不能理解为什么一个四川人要来浙江打工。现在想想，都是讨生活罢了，离家远一点也没事，生活有盼头更重要吧。我没他想不想以后回家去工作，没敢问，我怕他在四川没有家，也不想问这种太显而易见的问题。\n剪完发型还不错，图就不发了。\n回到家不仅思考起来，快剪店这样的店为什么以前没有，为什么这几年开始兴起了？我觉得可能有以下几点原因：\n疫情这几年，老百姓兜里没钱了，消费能力下降，这种快剪店满足了消费者对理发的直接诉求——便宜地把头发剪了 可以用便宜的价格把其他理发的客源吸引过来，客户粘性比较强。比如我这种能省则省的性格，大概率以后就在这家店剪发了。便宜、快速、好看、省钱，在产品的实用属性上全方位地拉满了。 人力资源便宜，并且理发这个行业没有门槛，剪发师傅是经过培训就上岗的，就像一个机器一样招待一个又一个客人。如果是一个新手，离了这家店，就没有了可以锻炼理发技术的地方，而自己单干又没有这个资本。其实程序员又何尝不是如此呢，拿着体面的工资，在大厂里拧着螺丝，不断地“锻炼”自己的本领，但离了公司之后又很少有人能有单干的资本（或技术/胆量）。 每一种行业模式都是在特定的时代背景下诞生的，后疫情时代，薄利多销成了小买卖还能盈利的一种模式。诶嘿，是不是和胖东来有点像。消费降级，物美价廉成了小老板姓的首选。\n","date":"2024-10-03T20:33:35+08:00","image":"https://example.com/p/kuai_jian_dian/567_huba17d3171a82c029ab6fcba65f72d0d6_1225315_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/kuai_jian_dian/","title":"什么是快剪店"},{"content":"This is an article.\n","date":"2024-10-02T22:47:18+08:00","permalink":"https://example.com/p/%E6%96%87%E7%AB%A0%E5%90%8D/","title":"文章名"}]